それでは発表させていただきます。よろしくお願いします。

自己紹介です。山梨と申します  
株式会社メイツという会社で Web バックエンドエンジニアをしております  
プライベートでは、AWS CDK のコントリビュートをしたり、AWS CDK 用の ESLint プラグインを開発しています  

今回、表示されているタイトルでお話ししますが、このサブタイトルの「固有ドメインにおけるコーディング規約」とは、「皆さんが所属されている会社だったりチーム独自のコーディング規約、あるいは、特定のライブラリ・ツールのコーディング規約」を示します。  
そして、本セッションの目的とは、カスタムルールの開発手法を知り、より詳細な粒度でコーディング規約を自動化できるようにすることです。  

このセッションでは、そういったカスタムルール開発の理解を深めるためのお話を、段階的にいたします。  
具体的にはこちらの流れでお話しします。

最初に、ESLint や ESLint カスタムルールの概要についてお話しします。  
そして、ESLint カスタムルールの開発に不可欠である、AST の概要についてお話しします。  
AST というと難易度が高い印象を受ける方も多いかもしれませんが、今回は入門として、コードを例に挙げ、大まかな概要について触れます。  
その後、実際にシナリオを立てて、ESLint カスタムルールの開発、型情報を使用した カスタムルールの開発へと進みます。

ではまず、ESLint についてです

ESLint とは、JavaScript の Linterで、一貫性のあるコードを書くためだったり、コードの品質や安全性を高めることを目的として使用されると思います。  
このESLint の特徴としては、typescript-eslint という ESLint プラグインを追加することにより、TypeScript 構文がサポートされること、そして、カスタムルールなどの開発が可能で、拡張性が高い点が挙げられます。
カスタムルールと聞くとあまり普段触れていないように思えますが、例えばeslint-plugin-vue, eslint-plugin-react のような、普段使用しているライブラリやそのコミュニティによって提供されるプラグインも、カスタムルールの一つです。

ここからは、そのカスタムルールの概要について、まとめます。  
ESLint には、カスタムルールを作成するためのモジュール、インターフェースが提供されており、そのインターフェースに沿って記述することで、カスタムルールを開発することができます。  
ここで記述されたカスタムルールは、eslint が AST を走査する際にフックされ、呼び出されます。
そのため、ESLint から提供された AST を参照し、それを元に、特定の条件に従うかを判定する実装を行う。というのが、カスタムールール開発の主な内容になります。

例えば、チームのコーディング規約として、if文は必ず Block を使用したい。つまり波括弧で囲うようにしたいというユースケースがあると仮定した場合、カスタムルールの内容はこちらのコードのようになります。  
このコードでは、`node`という変数名で JavaScript の AST を受け取り、それに対する操作を行なっています。  
このように、ESLint のカスタムルールを実装する際には、ASTへの理解が求められます。  

そのため、ここからは、AST の概要についてお話しします。

AST とは、ソースコードをパースした抽象構文木のことで、JavaScript の場合は JSONとして表現されます。  
例えば、`let count = 10`というコードは、非常に単純化すると、こちらのようなJSON構造で表現されるといったイメージです。  

```json
{
  "type": "Program",
  "body": [
    {
      "type": "VariableDeclaration",
      "declarations": [
        {
          "type": "VariableDeclarator",
          "id": {
            "type": "Identifier",
            "name": "count"
          },
          "init": {
            "type": "Literal",
            "value": 10,
            "raw": "10"
          }
        }
      ],
      "kind": "let"
    }
  ],
  "sourceType": "module"
}
```

(木構造のグラフを見せながら)
ASTはコードの構造を階層的に表現する「木構造」です。そして、各ノードがコードの一部を表し、ノード間の親子関係がコードの構文的な関係を示します。

こちらのJSONをを見てみると、最上位の`Program`ノードの中に、`VariableDeclaration`つまり変数宣言のノードがあることがわかります。  
この変数宣言は`kind: "let"`で宣言の種類を示し、`declarations`配列の中に具体的な変数情報を持っています。

その中の`VariableDeclarator`ノードが、`id`（変数名）と`init`（初期値）の関係を表現しています。  
`id`は`count`という名前の識別子、`init`は`10`という数値リテラルであることを示しています。

このように、1行のコードであっても、ASTはその構造を明確に階層化して表現しています。

そのASTをソースコードから生成する流れとしては、こちらの図のようになります。  
まずソースコードを字句解析してトークンに分解し、そのトークンを構文解析してASTを生成するといった流れです。

ここでの字句解析とは、ソースコードを予約語、変数名、記号などの、ある程度の意味の塊に分解することです。  
先ほどの、`let count = 10` というソースコードを字句解析すると、  
`let` と `count` と `=` と `10` と `;(セミコロン)` という単位に分解されます。

字句解析によって生成されたトークンは、構文解析器によって解析され、トークンの意味だったり、並び方を見て、階層構造を構築し、ASTが生成されます。  
ここで生成されるASTでは、スペースの数など、表面的な表現の違いが吸収され、コードの本質的な意味や構造だけを抽出して表現されます。  
ASTとはAbstract Syntax Tree の略ですが、この Abstract, つまり抽象とは、そういった表面的な表現の違いに左右されないことを意味します

ASTの概要について触れたところで、ここからは、実際にシナリオを立てて、そのシナリオを元にカスタムルールの開発についてお話しします
最終的には型情報を使用したルールについてお話ししますが、段階的に進めるために、まずは、ESLint のみを使用したカスタムルールの開発についてお話しします。ここでは型情報を扱わず JavaScript コードを対象として、ざっくりとしたカスタムルールの開発の流れを掴みます。  

今回は、先ほどと同様に、if文は必ず Block を使用したいというユースケースがあると仮定して、ルールを作成していきます。
開発の流れとしては、このようになります。

まず、テストケースとして、どのようなコードを正常として、どのようなコードを異常とするのかを考えます。その後、それぞれのコードのASTの内容を見ながら、ルールを実装していき、最後にテストの実装を行います。  
今回実装するルールは非常に単純なものですが、ルールの複雑性が増しても、基本的な流れは同じです。  

今回の、if文に必ずBlockを使用するというルールのテストケースを考えると、こちらのように、`{}`で囲われている場合は正常なケースとし、`{}`で囲われていない場合はエラーとします。  

こちらのコードを元に、実際のASTを見てみます。  
今回は非常に簡潔にした AST をスライドに載せていますが、実際に開発する上で、コードのASTを見る際には、こちらの [ast explorer](https://ast-explorer.dev/) というサイトが非常に便利です  

正常系としたいコードのASTと、異常系としたいコードのASTを比較してみると、`IfStatement`のノードのプロパティである`consequent`の中身に違いがあることが確認できます。  
正常系の方では、`consequent`のtypeが`BlockStatement`であるのに対し、異常系の方は、`ExpressionStatement`となっています。

```jsonc
// 正常系
{
  "type": "Program",
  "body": [
    {
      "type": "IfStatement",
      "test": {
        "type": "Literal",
        "value": true,
        "raw": "true"
      },
      "consequent": {
        "type": "BlockStatement",
        "body": [
          {
            "type": "ExpressionStatement",
            "expression": {
              "type": "CallExpression",
              "callee": {
                "type": "Identifier",
                "name": "sampleFn"
              },
              "arguments": [],
              "optional": false
            }
          }
        ]
      }
    }
  ],
  "sourceType": "module"
}
```

```jsonc
// 異常系
{
  "type": "Program",
  "body": [
    {
      "type": "IfStatement",
      "test": {
        "type": "Literal",
        "value": true,
        "raw": "true"
      },
      "consequent": {
        "type": "ExpressionStatement",
        "expression": {
          "type": "CallExpression",
          "callee": {
            "type": "Identifier",
            "name": "sampleFn"
          },
          "arguments": [],
          "optional": false
        }
      }
    }
  ],
  "sourceType": "module"
}
```

これを元に自然言語でルールを定義すると、「`IfStatement`のconsequentが`BlockStatement`でない場合はエラーにする」というようになります。

これを実際にコードに落すと、こちらのようになります。

今回定義するルールは、`IfStatement` の ノード に対する操作を行いたいので、`create`メソッドの`return`に`IfStatement`を指定しています。  
これにより、eslint が `IfStatement` のノードを走査する際に、記述した処理が実行されます。  

そして、自然言語で定義した通り、consequent の type が `BlockStatement` でない場合はエラーにします。  
これにより、ルールの実装が完了しましたので、最後にテストを実装します。  

テストを実装する際には、eslint から提供される `RuleTester`というモジュールを使用します。
そして、こちらのコードのように、ruleTesterの`run`メソッドを使用して、テスト対象のモジュールを指定し、正常系・異常系のテストケースを書きます。

その後、普段使用しているvitest, jest などのテストフレームワークを使用して、テストを実行し、成功を確認します。  
ここまでが、ESLint カスタムルールの基本的な開発の流れになります。

なんとなくのESLintカスタムルール作成の流れを掴んだところで、本題である、型情報を使用したカスタムルールの開発についてお話しします。
